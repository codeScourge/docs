---
title: "Project Structure"
icon: excavator
---
Let's start with the big picture: the project structure.

### development files
Open the `backend` folder.
As a Flask developer you will immediately see a familiar pattern:
- a `static` folder holding your CSS and JS
- a `templates` with your HTML Jinja templates
- our Flask application in `app.py`
- a `requirements.txt` file for our python dependencies
- a `gunicorn_config.py` file which configures our Gunicorn WSGI
- a Dockerfile to containarize the application for easier development and deployment
- a `static` folder holding the bundled `.js` and `.css` files, they will be imported in our HTML
- a `serverless.yml` file which defines our IAS (Infrastructure As Code), we will use it later to deploy a Lambda function

### secrets
One thing is missing though: the ``.env`` file. You will see an ``.env.example`` file with keys and empty values.
Rename it to `.env.local` and fill it with the according values througout the rest of this documentation. When 
you are ready to deploy to production, you will create a `.env` file and copy the info there.

Open `app.py`, you will see that if we run the file locally with `bash local.sh`, we will
use the `.env.local` file, otherwise we use the default `.env` file.
```python app.py
if __name__ == "__main__":
    dotenv.load_dotenv(".env.local")
    print("Loading development environment", flush=True)
else:
    dotenv.load_dotenv(".env")
    print("Loading production environment", flush=True)
```

Over the course I will refer to both as the `.env` file, use the one according
to your current stage

### bundling
Now let's look at the most interesting part: the bundling.
Open `package.json` and take a look at:
```json package.json
  "scripts": {
    "watch-js": "node build.mjs",
    "watch-css": "postcss ./src/css/*.css --dir ./backend/static/css --watch",
    "build-css": "postcss ./src/css/*.css --dir ./backend/static/css",
    "watch": "npm-run-all --parallel watch-css watch-js"
  },
```
You can run `watch-css`, `watch-css` or `watch` to watch and bundle the corresponding file types.
As you can see we use PostCSS and a `build.mjs` file to transpile our content from our `src` to our `static` folder.
Open `postcss.config.js`, here you can see the plugins that we use to:
- allow importing other `.css` files
- reduce our bundle size to a minimum
- use modern CSS features while making the bundle usable by legacy browsers

```js postcss.config.js
module.exports = {
    plugins: [
        require('postcss-import'),
        require('cssnano')({ // https://github.com/cssnano/cssnano
            preset: 'default',
        }),
        require('postcss-preset-env')({ // https://preset-env.cssdb.org/features/
            stage: 2
        })
    ],
};
```

Now take a look at the `build.mjs` file. Here we define the files that should be bundled. Then we loop over each of them
and start watching them for changes, when one occurs we create bundle with the same name.
```js build.mjs
import * as esbuild from 'esbuild'

const srcDir = "./src/js/"
const distDir = "./backend/static/js/"
const entryPoints = ["authenticated_home.jsx", "payed_home.jsx", "landing.jsx"];

for (const entryPoint of entryPoints) {
  let ctx = await esbuild.context({
    entryPoints: [srcDir + entryPoint],
    outfile: `${distDir}${entryPoint.split('.')[0]}.js`,
    bundle: true,
  });

  await ctx.watch();
  console.log(`Watching ${entryPoint}...`);
}
```

### deployment files
Besides the Dockerfile in `backend` we have a few more files, which we will need for deploying our Docker containers in a
provisioned way, for example the `nginx` folder, which holds all the Configuration for our web server. 
In the root dir you can see the Dockerfile for that.
When building, Docker copies the static files and serves them through Nginx
instead of our Flask application, since this is more efficient.

Besides that we have a ``docker-compose.yml`` file, for managing multiple Docker containers and making the communicate.

