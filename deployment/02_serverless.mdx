---
title: "Serverless"
icon: lambda
---

### What is Serverless Framework?
If you played around with the code-base, you will have seen the `serverless.yml` file in `backend`. It is a IAS
(Infrastructure As Code) Framework, used to define ressources in AWS or other providers. Open the file and let's 
look at how it works

### how it works
take a look at the functions tab:
```yml serverless.yml
functions:
  webapp:
    handler: app.lambda_handler
    timeout: 30 
    events:
      - http: ANY /
      - http: 'ANY /{proxy+}'
```
Here, `webapp` is simply the name we gave to this Lambda function, each other name will create another function. The event
describes how this function is invoked, in our case it is through an HTTP request. This means, that alongside the function,
also an AWS API Gateway is created. 

Other possible events are:
- sheduler (f.e. every 10 minutes)
- SQS (Simple Queue Service by AWS)

<img src="../images/lambda.png" alt="lambda and api-gateway interaction"/>

Besides that we get integrated logs using AWS CloudWatch.

Now look at the handler. Normally, lambda_handler, should be a function taking in an event and context object and processing
it accordingly. Since we already use Flask and want to continue using it, we will use a library called `serverless-wsgi`.
Open `app.py`. At the bottom of the file, you will see how we wrap our application and define the handler function
we point to in our YAML file.

```python app.py
if __name__ == "__main__":
    app.run(debug=True, port="8080")

else:
    # --- SLS (Lambda) ---
    import serverless_wsgi

    def lambda_handler(event, context): 
	    return serverless_wsgi.handle_request(app, event, context)
```

### secrets and permissions
Obviosly we don't want to reveal our secret keys inside the YAML configuration. By calling `useDotenv: true` at the
top of the file we allow serverless to read our keys and access them using `${env:KEY}`. An important thing to note,
is that our `.env` file is NOT copied to our Lambda function for security reasons. This means, that all the environment
variables we want to give to the code, have to be passed manually. This we do in provider.environments:

```yml serverless.yml
provider:
  environment:
    FROM_EMAIL: ${env:FROM_EMAIL}
    DYNAMO_TABLE_NAME: ${env:DYNAMO_TABLE_NAME}
    DOMAIN: ${env:DOMAIN}

    GITHUB_CLIENT_ID: ${env:GITHUB_CLIENT_ID}
    GITHUB_CLIENT_SECRET: ${env:GITHUB_CLIENT_SECRET}

    STRIPE_SECRET_KEY: ${env:STRIPE_SECRET_KEY}
    STRIPE_ENDPOINT_SECRET: ${env:STRIPE_ENDPOINT_SECRET}
    STRIPE_PACKAGE_ONE: ${env:STRIPE_PACKAGE_ONE}
    STRIPE_PACKAGE_TWO: ${env:STRIPE_PACKAGE_TWO}

    COMPANY_NAME: ${env:COMPANY_NAME}
    PERSONAL_NAME: ${env:PERSONAL_NAME}
    CONTACT_MAIL: ${env:CONTACT_MAIL}
    DESCRIPTION: ${env:DESCRIPTION}
    APPLICATION_NAME: ${env:APPLICATION_NAME}
    TITLE: ${env:TITLE}
    KEYWORDS: ${env:KEYWORDS}
    CURRENCY: ${env:CURRENCY}
```

Besides environment variables and come configuration, here we also define the permissions to other AWS ressources, since
we don't want to manually install and setup the AWS CLI on the lambda function. 

```yml serverless.yml
  iamRoleStatements:
    # allow only to access our table but all email identities
    - Effect: Allow
      Action:
        - dynamodb:*
      Resource: "arn:aws:dynamodb:${self:provider.region}:*:table/${self:provider.environment.DYNAMO_TABLE_NAME}"
    - Effect: Allow
      Action:
        - ses:SendEmail
        - ses:SendRawEmail
      Resource: "*"
```

### adding a Domain and SSL
Follow [this video](https://www.youtube.com/watch?v=JIKmsr1kuUo), while skipping the step of buying a new domain.
If deploying on the edge (meaning multiple endpoints close to the user), the certificate MUST be in us-east-1, since this
is the the only region CloudFront (the Content Delivery Network service by AWS) supports. We will use regional deployment,
this means use the region you have used for the rest of your ressources.

Now we will create a Custom Domain in AWS API Gateway and integrate it. For that we can use the `serverless-domain-manager`
plugin. It is configured inside the custom tab:

```yml serverless.yml
  customDomain:
    domainName: ${env:DOMAIN}
    stage: ${self:provider.stage}
    basePath: ''
    createRoute53Record: true
    createRoute53IPv6Record: true
    endpointType: REGIONAL
    apiType: rest
    hostedZoneId: ${env:HOSTED_ZONE_ID}
    certficateArn: ${env:CERTIFICATE_ARN}
```

For that we will have to set 3 more keys in our `.env` file:

- domainName should be a domain like api.ivanbokarev.top, that is controlled by Route53
- HOSTED_ZONE_ID should be the ID of the Route53 hosted zone 
- certificateArn should be the ARN (Amazon Ressource Name) for the certificate you just created

Now you can call `sls create_domain`. This will use the set information to create the new Domain.
<img src="../images/api-domain.png" alt="domain tap in API gateway"/>
If you want to delete it again (after you have already removed the Lambda function with `sls remove`), you 
can simply call `sls delete_domain`



### deploying
Before starting go to provider and change the region to the one you used for the rest of your ressources.
Now you can call `sls deply`. This will automatically create all the ressources